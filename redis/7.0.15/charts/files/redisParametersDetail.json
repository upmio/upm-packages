[
  {
    "key": "tcp-backlog",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": false,
    "range": "",
    "default": "511",
    "desc_en": "In high requests-per-second environments you need an high backlog in order to avoid slow clients connections issues.",
    "desc_zh": "在高每秒请求的环境下，需要较大的 backlog 以避免慢客户端连接问题。"
  },
  {
    "key": "timeout",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "0",
    "desc_en": "Close the connection after a client is idle for N seconds (0 to disable).",
    "desc_zh": "当客户端空闲 N 秒后关闭连接（0 表示禁用）。"
  },
  {
    "key": "tcp-keepalive",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "300",
    "desc_en": "If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence of communication. This is useful for two reasons:1) Detect dead peers.2) Take the connection alive from the point of view of network equipment in the middle.On Linux, the specified value (in seconds) is the period used to send ACKs.",
    "desc_zh": "若非 0，则在无通信时使用 SO_KEEPALIVE 向客户端发送 TCP ACK。这有两点好处：1）检测已失效的对端；2）从中间网络设备视角保持连接存活。在 Linux 上，指定的值（秒）为发送 ACK 的周期。"
  },
  {
    "key": "daemonize",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": false,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "By default Redis does not run as a daemon. Use 'yes' if you need it.",
    "desc_zh": "默认 Redis 不以守护进程方式运行。如有需要请设为 yes。"
  },
  {
    "key": "loglevel",
    "scope": "",
    "section": "defaults",
    "type": "Enumeration",
    "dynamic": true,
    "range": "[\"debug\",\"verbose\",\"notice\",\"warning\"]",
    "default": "",
    "desc_en": "Specify the server verbosity level.",
    "desc_zh": "指定服务器日志的详细级别。"
  },
  {
    "key": "databases",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": false,
    "range": "",
    "default": "16",
    "desc_en": "Set the number of databases.",
    "desc_zh": "设置数据库数量。"
  },
  {
    "key": "always-show-logo",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": false,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "show a ASCII art logo in startup logs",
    "desc_zh": "在启动日志中显示 ASCII 艺术风格的标志。"
  },
  {
    "key": "save",
    "scope": "",
    "section": "defaults",
    "type": "String",
    "dynamic": true,
    "range": "",
    "default": "[\"3600 1\", \"300 100\", \"60 10000\"]",
    "desc_en": "Save the DB on disk:save <seconds> <changes>",
    "desc_zh": "将数据库保存到磁盘：save <秒> <变更次数>。"
  },
  {
    "key": "rdbcompression",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "Compress string objects using LZF when dump .rdb databases",
    "desc_zh": ".rdb 导出时使用 LZF 压缩字符串对象。"
  },
  {
    "key": "rdbchecksum",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": false,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "RDB file CRC64 checksum",
    "desc_zh": "对 RDB 文件启用 CRC64 校验。"
  },
  {
    "key": "maxclients",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "10000",
    "desc_en": "Set the max number of connected clients at the same time.",
    "desc_zh": "设置允许同时连接的最大客户端数量。"
  },
  {
    "key": "maxmemory-policy",
    "scope": "",
    "section": "defaults",
    "type": "Enumeration",
    "dynamic": true,
    "range": "[\"allkeys-lru\",\"volatile-lfu\",\"allkeys-lfu\",\"volatile-random\",\"allkeys-random\",\"volatile-ttl\",\"noeviction\"]",
    "default": "noeviction",
    "desc_en": "how Redis will select what to remove when maxmemory is reached.",
    "desc_zh": "达到 maxmemory 时 Redis 的键淘汰策略。"
  },
  {
    "key": "maxmemory-samples",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "5",
    "desc_en": "LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated algorithms (in order to save memory), so you can tune it for speed or accuracy",
    "desc_zh": "LRU、LFU 与最小 TTL 为近似算法（以节省内存），可通过采样数在速度与准确性间权衡。"
  },
  {
    "key": "lazyfree-lazy-eviction",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "configure each case specificallyin order to instead release memory in a non-blocking way",
    "desc_zh": "为该场景启用惰性释放，以非阻塞方式释放内存（淘汰）。"
  },
  {
    "key": "lazyfree-lazy-expire",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "configure each case specificallyin order to instead release memory in a non-blocking way",
    "desc_zh": "为 key 过期启用惰性释放，以非阻塞方式释放内存。"
  },
  {
    "key": "replica-lazy-flush",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "configure each case specificallyin order to instead release memory in a non-blocking way",
    "desc_zh": "为副本刷新启用惰性释放，以非阻塞方式释放内存。"
  },
  {
    "key": "appendonly",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "aof persistence",
    "desc_zh": "AOF 持久化开关。"
  },
  {
    "key": "appendfsync",
    "scope": "",
    "section": "defaults",
    "type": "Enumeration",
    "dynamic": true,
    "range": "[\"always\",\"everysec\",\"no\"]",
    "default": "everysec",
    "desc_en": "AOF persistence strategy",
    "desc_zh": "AOF 刷盘策略。"
  },
  {
    "key": "no-appendfsync-on-rewrite",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "no",
    "desc_en": "When the AOF fsync policy is set to always or everysec, and a background saving process (a background save or AOF log background rewriting) is performing a lot of I/O against the disk, in some Linux configurations this currently, as even performing fsync in a different thread will block. If you have latency problems turn this to \"yes\". Otherwise leave it as \"no\" that is the safest pick from the point of view of durability.",
    "desc_zh": "当 AOF fsync 策略为 always 或 everysec，且有后台保存或 AOF 重写等产生大量磁盘 I/O 时，在某些 Linux 配置下即使在不同线程执行 fsync 也会阻塞。若存在延迟问题将其设为 yes；否则保持 no 以获得更高的数据持久性安全。"
  },
  {
    "key": "auto-aof-rewrite-percentage",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "100",
    "desc_en": "Automatic rewrite of the append only file.Redis is able to automatically rewrite the log file implicitly calling BGREWRITEAOF when the AOF log size grows by the specified percentage.",
    "desc_zh": "当 AOF 日志大小按指定百分比增长时，自动调用 BGREWRITEAOF 进行重写。"
  },
  {
    "key": "auto-aof-rewrite-min-size",
    "scope": "",
    "section": "defaults",
    "type": "String",
    "dynamic": true,
    "range": "",
    "default": "64mb",
    "desc_en": "specify a minimal size for the AOF file to be rewritten",
    "desc_zh": "触发 AOF 重写的最小文件大小。"
  },
  {
    "key": "aof-load-truncated",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "Automatically repair AOF files when loading AOF files",
    "desc_zh": "加载 AOF 时自动修复被截断的 AOF 文件。"
  },
  {
    "key": "aof-use-rdb-preamble",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "When rewriting the AOF file, Redis is able to use an RDB preamble in the AOF file for faster rewrites and recoveries. When this option is turned on the rewritten AOF file is composed of two different stanzas: [RDB file][AOF tail].",
    "desc_zh": "重写 AOF 时，可在 AOF 文件中使用 RDB 头以加快重写与恢复。启用后，重写后的 AOF 由两部分组成：[RDB 文件][AOF 尾部]。"
  },
  {
    "key": "lua-time-limit",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "5000",
    "desc_en": "Max execution time of a Lua script in milliseconds.Set it to 0 or a negative value for unlimited execution without warnings.",
    "desc_zh": "Lua 脚本的最大执行时间（毫秒）。设为 0 或负值表示无限制且不告警。"
  },
  {
    "key": "cluster-node-timeout",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "15000",
    "desc_en": "Cluster node timeout is the amount of milliseconds a node must be unreachable for it to be considered in failure state.",
    "desc_zh": "集群节点超时时长（毫秒）。节点不可达超过该时长将被视为故障。"
  },
  {
    "key": "cluster-require-full-coverage",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "By default Redis Cluster nodes stop accepting queries if they detect there is at least an hash slot uncovered (no available node is serving it).However sometimes you want the subset of the cluster which is working, to continue to accept queries for the part of the key space that is still covered. In order to do so, just set the cluster-require-full-coverage option to no.",
    "desc_zh": "默认情况下，若检测到存在未覆盖的散列槽位（无可用节点服务该槽位），Redis Cluster 节点将停止接收请求。如需在仍有部分槽位被覆盖时继续对外提供服务，将此项设为 no。"
  },
  {
    "key": "slowlog-log-slower-than",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "10000",
    "desc_en": "The Redis Slow Log is a system to log queries that exceeded a specified execution time, in microseconds",
    "desc_zh": "慢日志记录执行时间超过指定阈值（微秒）的命令。"
  },
  {
    "key": "slowlog-max-len",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "128",
    "desc_en": "The maximum number of entries stored in slowlog.",
    "desc_zh": "慢日志保留的最大条目数。"
  },
  {
    "key": "latency-monitor-threshold",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "0",
    "desc_en": " The system only logs operations that were performed in a time equal or greater than the amount of milliseconds specified via the latency-monitor-threshold configuration directive. When its value is set to zero, the latency monitor is turned off.",
    "desc_zh": "仅记录耗时不小于该阈值（毫秒）的操作；为 0 时关闭延迟监控。"
  },
  {
    "key": "notify-keyspace-events",
    "scope": "",
    "section": "defaults",
    "type": "String",
    "dynamic": true,
    "range": "",
    "default": "",
    "desc_en": "Redis can notify Pub/Sub clients about events happening in the key space.",
    "desc_zh": "可通过 Pub/Sub 通知键空间发生的事件。"
  },
  {
    "key": "hash-max-ziplist-entries",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "512",
    "desc_en": "Hashes are encoded using a memory efficient data structure when they have a small number of entries, and the biggest entry does not exceed a given threshold",
    "desc_zh": "当条目数较少且最大条目不超过阈值时，哈希使用内存高效的数据结构编码。"
  },
  {
    "key": "hash-max-ziplist-value",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "64",
    "desc_en": "Hashes are encoded using a memory efficient data structure when they have a small number of entries, and the biggest entry does not exceed a given threshold",
    "desc_zh": "当条目数较少且最大条目不超过阈值时，哈希使用内存高效的数据结构编码（条目值大小阈值）。"
  },
  {
    "key": "list-max-ziplist-size",
    "scope": "",
    "section": "defaults",
    "type": "Enumeration",
    "dynamic": true,
    "range": "[\"-5\",\"-4\",\"-3\",\"-2\",\"-1\"]",
    "default": "-2",
    "desc_en": "Lists are also encoded in a special way to save a lot of space.The number of entries allowed per internal list node can be specified as a fixed maximum size or a maximum number of elements.",
    "desc_zh": "列表也采用特殊编码以节省空间。每个内部节点允许的条目数可指定为固定最大大小或最大元素数。"
  },
  {
    "key": "list-compress-depth",
    "scope": "",
    "section": "defaults",
    "type": "Enumeration",
    "dynamic": true,
    "range": "[0,1,2,3]",
    "default": "0",
    "desc_en": "Lists may also be compressed.Compress depth is the number of quicklist ziplist nodes from each side of the list to exclude from compression. ",
    "desc_zh": "列表也可被压缩。压缩深度指列表两端各自不参与压缩的 quicklist ziplist 节点数。"
  },
  {
    "key": "set-max-intset-entries",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "512",
    "desc_en": "The following configuration setting sets the limit in the size of theset in order.",
    "desc_zh": "设置使用 intset 编码时集合大小（元素数量）的阈值上限。"
  },
  {
    "key": "zset-max-ziplist-entries",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "128",
    "desc_en": "Similarly to hashes and lists, sorted sets are also specially encoded in order to save a lot of space. This encoding is only used when the length and elements of a sorted set are below the following limits.",
    "desc_zh": "与哈希和列表类似，为节省空间，有序集合在规模较小时采用特殊编码（元素数量阈值）。"
  },
  {
    "key": "zset-max-ziplist-value",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "64",
    "desc_en": "Similarly to hashes and lists, sorted sets are also specially encoded in order to save a lot of space. This encoding is only used when the length and elements of a sorted set are below the following limits.",
    "desc_zh": "与哈希和列表类似，为节省空间，有序集合在规模较小时采用特殊编码（元素值大小阈值）。"
  },
  {
    "key": "hll-sparse-max-bytes",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "3000",
    "desc_en": "HyperLogLog sparse representation bytes limit.",
    "desc_zh": "HyperLogLog 稀疏表示的最大字节数限制。"
  },
  {
    "key": "stream-node-max-bytes",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "4096",
    "desc_en": "Streams macro node max size.",
    "desc_zh": "Stream 宏节点的最大大小（字节）。"
  },
  {
    "key": "stream-node-max-entries",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "100",
    "desc_en": "Streams macro node maxitems.",
    "desc_zh": "Stream 宏节点的最大条目数。"
  },
  {
    "key": "activerehashing",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "",
    "desc_en": "Control whether active rehashing is turned on",
    "desc_zh": "控制是否启用主动 rehash。"
  },
  {
    "key": "client-output-buffer-limit",
    "scope": "",
    "section": "defaults",
    "type": "String",
    "dynamic": true,
    "range": "",
    "default": "[\"normal 0 0 0\", \"replica 256mb 64mb 60\", \"pubsub 32mb 8mb 60\"]",
    "desc_en": " Controlling Client Output Buffer Limits",
    "desc_zh": "控制客户端输出缓冲区的限制。"
  },
  {
    "key": "hz",
    "scope": "",
    "section": "defaults",
    "type": "Integer",
    "dynamic": true,
    "range": "",
    "default": "10",
    "desc_en": "Redis calls an internal function to perform many background tasks, like closing connections of clients in timeout, purging expired keys that are never requested, and so forth. Not all tasks are performed with the same frequency, but Redis checks for tasks to perform according to the specified \"hz\" value.",
    "desc_zh": "Redis 会定期执行诸如关闭超时连接、清理从未被请求的过期键等后台任务；实际检查频率由 hz 值决定。"
  },
  {
    "key": "dynamic-hz",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "Controls whether dynamic adjustment of hz is enabled.",
    "desc_zh": "控制是否启用对 hz 的动态调整。"
  },
  {
    "key": "aof-rewrite-incremental-fsync",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "Configure whether to use incremental fsync operations when performing AOF rewrites. When a child rewrites the AOF file, if the following option is enabled the file will be fsync-ed every 32 MB of data generated.",
    "desc_zh": "配置在 AOF 重写期间是否使用增量 fsync；启用后每生成 32MB 数据执行一次 fsync。"
  },
  {
    "key": "rdb-save-incremental-fsync",
    "scope": "",
    "section": "defaults",
    "type": "Boolean",
    "dynamic": true,
    "range": "[\"no\",\"yes\"]",
    "default": "yes",
    "desc_en": "Configure whether to use incremental fsync operations when executing RDB snapshots. When redis saves RDB file, if the following option is enabled the file will be fsync-ed every 32 MB of data generated.",
    "desc_zh": "配置在执行 RDB 快照时是否使用增量 fsync；启用后每生成 32MB 数据执行一次 fsync。"
  }
]
